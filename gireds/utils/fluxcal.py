import numpy as np
import pyfits as pf
import ifscube.spectools as st
from scipy.optimize import minimize
from scipy.interpolate import interp1d
from scipy.interpolate import UnivariateSpline as uvspline


class stdstar():
    """
    A class for the data output of IRAF's standard task.
    """

    def __init__(self, std):

        self.title = std[0].split()
        self.exptime, self.airmass = [float(self.title[i]) for i in [3, 4]]

        self.wl, self.flambda, self.bandpass, self.adu =\
            np.loadtxt(std, skiprows=1, unpack=True)

        return

    def build_c(self):
        """
        Evaluates the sensibility conversion function.

        C = 2.5 log10 (A / (T B F))

        Where A is the instrumental counts, T is the exposure time,
        B is the width of the bandpass and F is the reference flux
        per unit wavelength.
        """

        self.c = 2.5 * np.log10(
            self.adu / self.exptime / self.bandpass / self.flambda)

        return

    def extinction(self, extfile):
        """
        Not working yet!
        """

        # e = np.loadtxt(extfile)
        # ext = interp1d(e[:, 0], e[:, 1])
        # c = 2.5 * (np.log10(obscounts / exptime / bp / flambda)) + \
        #            airmass * ext(wl)

        pass

    def interp(self, bounds_error=False, fill_value=np.nan):

        self.adu_interp = interp1d(
            self.wl, self.adu, bounds_error=bounds_error,
            fill_value=fill_value)
        self.flambda_interp = interp1d(
            self.wl, self.flambda, bounds_error=bounds_error,
            fill_value=fill_value)
        self.c_interp = interp1d(
            self.wl, self.c, bounds_error=bounds_error,
            fill_value=fill_value)

        return


def sensitivity(observed, reference, extinction=None, fnuzero=3.68e-20):
    """
    Function designed fit a sensitivity function based on the
    comparison between the osbervation of a standard star and its
    flux calibrated spectrum.
    """

    h = pf.getheader(observed, ext=1)
    exptime, airmass = h['exptime'], h['airmass']
    obswl = st.get_wl(observed, hdrext=1, dataext=1)
    refwl, mag, bp = np.loadtxt(reference, unpack=True)

    trim = (refwl - bp[0] > obswl[0]) & (refwl + bp[-1] < obswl[-1])
    refwl, mag, bp = refwl[trim], mag[trim], bp[trim]

    obsdata = pf.getdata(observed, ext=1)

    obsbp = np.array([
        sum(obsdata[(obswl > refwl[i] - bp[i]/2.) & (obswl < refwl[i] +
                    bp[i]/2.)]) for i in range(len(refwl))])

    flambda = fnuzero * 10 ** (-0.4 * mag) * 2.99792458e+18 / refwl ** 2

    if extinction is None:
        c = 2.5 * np.log10(obsbp / exptime / bp / flambda)
    else:
        e = np.loadtxt(extinction)
        ext = interp1d(e[:, 0], e[:, 1])
        c = 2.5 * (np.log10(obsbp / exptime / bp / flambda)) + \
            airmass * ext(refwl)

    return refwl, obsbp, c, flambda


def shiftspectra(lambdas, fluxes):
    """
    Shifts the spectra and returns the additive term to be applied
    to each spectrum in order to minimize the distance between them.

    Parameters
    ----------
    lambdas : list of arrays
        List of numpy 1d arrays containing the wavelength coordinates.
    fluxes : list of arrays
        List of numpy 1d arrays containing the flux coordinates.

    """

    intersect = np.intersect1d(lambdas[0], lambdas[1])
    if len(lambdas) > 2:
        for i in lambdas[2:]:
            intersect = np.intersect1d(intersect, i)

    intersect_args = []
    for i in lambdas:
        intersect_args.append(np.array([j in intersect for j in i]))

    avg = np.average(np.array([fluxes[i][intersect_args[i]]
                               for i in range(len(fluxes))]))

    offset = []

    for i, j in enumerate(fluxes):

        def res(p):
            return (avg - (np.average(j) + p[0])) ** 2

        ofs = minimize(res, x0=[0], method='slsqp')
        offset.append(ofs.x)

    return offset


def sensfunc(std, extinction=None, mask=None, shift=False, spl_options={},
             output='sens.fits', wl_lims=None):
    """
    Fits a sensibility function to a table provided by IRAF's
    standard task.

    Parameters
    ----------
    std : string
        Name of the file generated by STANDARD
    extinction : string
        Name of the extinction definition file, or None if no
        extinction correction is to be applied.
            *** NOT IMPLEMENTED YET ***
    mask : string
        Name of the file containing the mask definition.
            *** NOT IMPLEMENTED YET ***
    shift : boolean
        Shifts instrumental counts to match multiple standard
        star observations.
    spl_options : dic
        Options passed directly to scipy.interpolate.UnivariateSpline.
    output : string
        Name of the output sensibility file.
    """

    with open(std, 'r') as f:
        fl = f.readlines()

    idx = [i for i in range(len(fl)) if '.fits' in fl[i]]
    fitsfiles = [fl[i][1:fl[i].index('.fits') + 5] for i in idx]

    stars = []

    for i, j in enumerate(idx):
        if j != idx[-1]:
            stars.append(stdstar(fl[j:idx[i + 1]]))
        else:
            stars.append(stdstar(fl[j:]))

    if len(stars) > 1:
        if shift:
            offsets = shiftspectra([j.wl for j in stars],
                                   [j.adu for j in stars])

            for i, star in enumerate(stars):
                star.adu += offsets[i]

        for star in stars:
            star.build_c()
            star.interp()

        x = np.unique(np.concatenate([s.wl for s in stars]))

        if wl_lims is not None:
            x = x[(x >= wl_lims[0]) & (x <= wl_lims[1])]

        wl = np.arange(x[0], x[-1], 1)
        c = np.nanmean([s.c_interp(x) for s in stars], 0)

    else:
        star = stars[0]

        star.build_c()
        star.interp()

        x = star.wl

        if wl_lims is not None:
            x = x[(x >= wl_lims[0]) & (x <= wl_lims[1])]

        wl = np.arange(x[0], x[-1], 1)
        c = star.c_interp(x)

    spl = np.array(uvspline(x, c, **spl_options)(wl), dtype='float32')

    hdr = pf.Header()

    orighdr = pf.open(fitsfiles[0])[0].header
    hdic = {'crval1': wl[0],
            'crpix1': 1.,
            'object': 'Sens',
            'cd1_1': 1.,
            'cdelt1': 1.,
            'qestate': 'no',
            'WAT0_001': 'system=equispec',
            'WAT1_001': 'wtype=linear label=Wavelength units=Angstroms',
            'ctype1': 'linear',
            'APNUM1': '1 1',
            'observat': orighdr['observat'],
            'instrume': orighdr['instrume'],
            'grating': orighdr['grating'],
            'filter1': orighdr['filter1'],
            'maskname': orighdr['maskname'],
            'detector': orighdr['detector']
            }

    for i in hdic:
        hdr[i] = hdic[i]

    hdu = pf.PrimaryHDU(data=spl, header=hdr)
    hdulist = pf.HDUList([hdu])

    hdulist.writeto(output, clobber=True)

    return x, c, wl, spl, stars
